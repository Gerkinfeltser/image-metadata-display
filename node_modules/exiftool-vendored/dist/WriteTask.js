"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WriteTask = exports.DefaultWriteTaskOptions = exports.htmlEncode = void 0;
const he_1 = require("he");
const _path = __importStar(require("node:path"));
const DateTime_1 = require("./DateTime");
const DefaultExifToolOptions_1 = require("./DefaultExifToolOptions");
const ErrorsAndWarnings_1 = require("./ErrorsAndWarnings");
const ExifToolTask_1 = require("./ExifToolTask");
const FilenameCharsetArgs_1 = require("./FilenameCharsetArgs");
const Number_1 = require("./Number");
const Object_1 = require("./Object");
const Pick_1 = require("./Pick");
const String_1 = require("./String");
const Struct_1 = require("./Struct");
const sep = String.fromCharCode(31); // < unit separator
// this is private because it's very special-purpose for just encoding ExifTool
// WriteTask args:
function htmlEncode(s) {
    return (
    // allowUnsafeSymbols is true because ExifTool doesn't care about &, <, >, ", ', * and `
    (0, he_1.encode)(s, { decimal: true, allowUnsafeSymbols: true })
        // `he` doesn't encode whitespaces (like newlines), but we need that:
        .replace(/\s/g, (m) => (m === " " ? " " : `&#${m.charCodeAt(0)};`)));
}
exports.htmlEncode = htmlEncode;
function enc(o, structValue = false) {
    if (o == null) {
        return "";
    }
    else if ((0, Number_1.isNumber)(o)) {
        return String(o);
    }
    else if ((0, String_1.isString)(o)) {
        // Structs need their own escaping here.
        // See https://exiftool.org/struct.html#Serialize
        return htmlEncode(structValue ? o.replace(/[,[\]{}|]/g, (ea) => "|" + ea) : o);
        // const s = htmlEncode(String(o))
    }
    else if ((0, DateTime_1.isDateOrTime)(o)) {
        return (0, DateTime_1.toExifString)(o);
    }
    else if (Array.isArray(o)) {
        const primitiveArray = o.every((ea) => (0, String_1.isString)(ea) || (0, Number_1.isNumber)(ea));
        return primitiveArray
            ? `${o.map((ea) => enc(ea)).join(sep)}`
            : `[${o.map((ea) => enc(ea)).join(",")}]`;
    }
    else if ((0, Struct_1.isStruct)(o)) {
        // See https://exiftool.org/struct.html#Serialize
        return `{${(0, Object_1.keys)(o)
            .map((k) => enc(k, true) + "=" + enc(o[k], true))
            .join(",")}}`;
    }
    else {
        throw new Error("cannot encode " + JSON.stringify(o));
    }
}
exports.DefaultWriteTaskOptions = {
    ...(0, Pick_1.pick)(DefaultExifToolOptions_1.DefaultExifToolOptions, "useMWG"),
};
class WriteTask extends ExifToolTask_1.ExifToolTask {
    constructor(sourceFile, args) {
        super(args);
        this.sourceFile = sourceFile;
        this.args = args;
    }
    static for(filename, tags, extraArgs = [], options) {
        var _a, _b, _c;
        const sourceFile = _path.resolve(filename);
        const args = [
            ...FilenameCharsetArgs_1.Utf8FilenameCharsetArgs,
            `-sep`,
            `${sep}`,
            "-E", // < html encoding https://exiftool.org/faq.html#Q10
        ];
        if ((_a = options === null || options === void 0 ? void 0 : options.useMWG) !== null && _a !== void 0 ? _a : exports.DefaultWriteTaskOptions.useMWG) {
            args.push("-use", "MWG");
        }
        // Special handling for GPSLatitude and GPSLongitude (due to differences
        // in EXIF, XMP, and MIE encodings). See
        // https://exiftool.org/forum/index.php?topic=14488.0 and
        // https://github.com/photostructure/exiftool-vendored.js/issues/131
        if ((0, Number_1.isNumber)(tags.GPSLatitude)) {
            (_b = tags.GPSLatitudeRef) !== null && _b !== void 0 ? _b : (tags.GPSLatitudeRef = tags.GPSLatitude >= 0 ? "N" : "S");
        }
        if ((0, Number_1.isNumber)(tags.GPSLongitude)) {
            (_c = tags.GPSLongitudeRef) !== null && _c !== void 0 ? _c : (tags.GPSLongitudeRef = tags.GPSLongitude >= 0 ? "E" : "W");
        }
        for (const key of (0, Object_1.keys)(tags)) {
            const val = tags[key];
            args.push(`-${key}=${enc(val)}`);
        }
        args.push(...extraArgs);
        args.push(sourceFile);
        return new WriteTask(sourceFile, args);
    }
    toString() {
        return "WriteTask(" + this.sourceFile + ")";
    }
    // we're handling the stderr output ourselves, so we tell ExifToolTask that all stderr output is not ignorable so we can capture the warnings
    parse(data, error) {
        var _a, _b, _c, _d;
        if (error != null)
            throw error;
        let created = 0;
        let updated = 0;
        let unchanged = 0;
        for (const line of (0, String_1.splitLines)(data)) {
            const m_created = CreatedRE.exec(line);
            if (m_created != null) {
                created += (_a = (0, Number_1.toInt)(m_created[1])) !== null && _a !== void 0 ? _a : 0;
                continue;
            }
            // careful! we need to apply UnchangedRE before UpdateRE, as both match
            // "updated"
            const m_unchanged = UnchangedRE.exec(line);
            if (m_unchanged != null) {
                unchanged += (_b = (0, Number_1.toInt)(m_unchanged[1])) !== null && _b !== void 0 ? _b : 0;
                continue;
            }
            const m_updated = UpdatedRE.exec(line);
            if (m_updated != null) {
                updated += (_c = (0, Number_1.toInt)(m_updated[1])) !== null && _c !== void 0 ? _c : 0;
                continue;
            }
            // if we get here, we didn't match any of the expected patterns.
            this.warnings.push("Unexpected output from ExifTool: " + line);
        }
        const w = (_d = (0, ErrorsAndWarnings_1.errorsAndWarnings)(this).warnings) !== null && _d !== void 0 ? _d : [];
        return {
            created,
            updated,
            unchanged,
            ...(w.length === 0 ? {} : { warnings: w }),
        };
    }
}
exports.WriteTask = WriteTask;
const CreatedRE = /(\d+) .*?\bcreated\b/i;
const UnchangedRE = /(\d+) .*?(?:\bweren't updated|unchanged\b)/i;
const UpdatedRE = /(\d+) .*?\bupdated\b/i;
//# sourceMappingURL=WriteTask.js.map