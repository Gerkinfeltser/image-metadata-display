"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getZoneName = exports.equivalentZones = exports.extractTzOffsetFromUTCOffset = exports.inferLikelyOffsetMinutes = exports.extractTzOffsetFromDatestamps = exports.extractTzOffsetFromTags = exports.extractZone = exports.offsetMinutesToZoneName = exports.validTzOffsetMinutes = exports.zoneToShortOffset = exports.normalizeZone = exports.defaultVideosToUTC = exports.isZoneValid = exports.isUTC = exports.UnsetZoneName = exports.UnsetZone = exports.UnsetZoneOffsetMinutes = void 0;
const luxon_1 = require("luxon");
const BinaryField_1 = require("./BinaryField");
const CapturedAtTagNames_1 = require("./CapturedAtTagNames");
const ExifDate_1 = require("./ExifDate");
const ExifDateTime_1 = require("./ExifDateTime");
const ExifTime_1 = require("./ExifTime");
const Lazy_1 = require("./Lazy");
const Maybe_1 = require("./Maybe");
const Number_1 = require("./Number");
const Pick_1 = require("./Pick");
const String_1 = require("./String");
// Unique values from https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
const ValidTimezoneOffsets = [
    "-12:00",
    "-11:00",
    "-10:30",
    "-10:00",
    "-09:30",
    "-09:00",
    "-08:30",
    "-08:00",
    "-07:30",
    "-07:00",
    "-06:00",
    "-05:00",
    "-04:30",
    "-04:00",
    "-03:30",
    "-03:00",
    "-02:30",
    "-02:00",
    "-01:00",
    "-00:44",
    "-00:25:21", // LOL https://en.wikipedia.org/wiki/UTC%E2%88%9200:25:21
    "+00:00",
    "+00:20",
    "+00:30",
    "+01:00",
    "+01:24",
    "+01:30",
    "+02:00",
    "+02:30",
    "+03:00",
    "+03:30",
    "+04:00",
    "+04:30",
    "+04:51", // LOL https://en.wikipedia.org/wiki/UTC%2B04:51
    "+05:00",
    "+05:30",
    "+05:40",
    "+05:45",
    "+06:00",
    "+06:30",
    "+07:00",
    "+07:20",
    "+07:30",
    "+08:00",
    "+08:30",
    "+08:45",
    "+09:00",
    "+09:30",
    "+09:45",
    "+10:00",
    "+10:30",
    "+11:00",
    "+11:30",
    "+12:00",
    "+12:45",
    "+13:00",
    "+13:45",
    "+14:00",
];
function offsetToMinutes(offset) {
    const [h, m] = offset.split(":").map(Number);
    // we can't just return `h * 60 + m`: that doesn't work with negative
    // offsets (minutes will be positive but hours will be negative)
    const sign = h < 0 ? -1 : 1;
    return h * 60 + sign * m;
}
const ValidOffsetMinutes = (0, Lazy_1.lazy)(() => new Set(ValidTimezoneOffsets.map(offsetToMinutes)));
/**
 * Zone instances with this offset are a placeholder for being "unset".
 */
exports.UnsetZoneOffsetMinutes = -1;
/**
 * This is a placeholder for dates where the zone is unknown/unset, because
 * Luxon doesn't officially support "unset" zones.
 */
exports.UnsetZone = luxon_1.Info.normalizeZone(exports.UnsetZoneOffsetMinutes);
/**
 * Zone instances with this name are a placeholder for being "unset".
 */
exports.UnsetZoneName = exports.UnsetZone.name;
const Zulus = [
    luxon_1.FixedOffsetZone.utcInstance,
    0,
    -0,
    "UTC",
    "GMT",
    "Z",
    "+0",
    "+00:00",
    "UTC+0",
    "GMT+0",
    "UTC+00:00",
    // ...sigh, so much for "normalizeZone"...
];
function isUTC(zone) {
    var _a;
    const z = zone;
    return (zone != null && (Zulus.includes(z) || Zulus.includes((_a = z.zoneName) !== null && _a !== void 0 ? _a : z.fixed)));
}
exports.isUTC = isUTC;
function isZoneValid(zone) {
    return (zone != null && zone.isValid && Math.abs(zone.offset(Date.now())) < 14 * 60);
}
exports.isZoneValid = isZoneValid;
/**
 * If `tzSource` matches this value, the tags are from a video, and we had to
 * resort to assuming time fields are in UTC.
 * @see https://github.com/photostructure/exiftool-vendored.js/issues/113
 */
exports.defaultVideosToUTC = "defaultVideosToUTC";
// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones -- not that
// "WET" and "W-SU" are full TZs
const IanaFormatRE = /^\w{2,15}(?:\/\w{3,15})?$/;
// Luxon requires fixed-offset zones to look like "UTC+H", "UTC-H",
// "UTC+H:mm", "UTC-H:mm":
const FixedFormatRE = /^UTC[+-]\d{1,2}(?::\d\d)?$/;
/**
 * @param input must be either a number, which is the offset in minutes, or a
 * string in the format "UTC+H" or "UTC+HH:mm"
 */
function normalizeZone(input) {
    // wrapped in a try/catch as Luxon.settings.throwOnInvalid may be true:
    try {
        // Info.normalizeZone returns the system zone if the input is null or
        // blank (!!!), but we want to return undefined instead:
        // Info.normalizeZone(null) returns the system zone, which isn't what we
        // (ever!) want.
        if (input == null)
            return;
        if (input instanceof luxon_1.Zone) {
            return isZoneValid(input) ? input : undefined;
        }
        let z = input;
        if (typeof z === "string") {
            z = z.replace(/^(?:Zulu|Z|GMT)(?:\b|$)/, "UTC");
            // Info.normalizeZone("") returns the system zone, which we never want.
            // We also don't need to tease Info.normalizeZone with obviously
            // non-offset inputs:
            if ((0, String_1.blank)(z) || (!IanaFormatRE.test(z) && !FixedFormatRE.test(z))) {
                return;
            }
        }
        const result = luxon_1.Info.normalizeZone(z);
        return isZoneValid(result) && result.name !== exports.UnsetZoneName
            ? result
            : undefined;
    }
    catch {
        return;
    }
}
exports.normalizeZone = normalizeZone;
/**
 * @param ts must be provided if the zone is not a fixed offset
 * @return the zone offset (in "Â±HH:MM" format) for the given zone, or "" if
 * the zone is invalid
 */
function zoneToShortOffset(zone, ts) {
    var _a, _b;
    return (_b = (_a = normalizeZone(zone)) === null || _a === void 0 ? void 0 : _a.formatOffset(ts !== null && ts !== void 0 ? ts : Date.now(), "short")) !== null && _b !== void 0 ? _b : "";
}
exports.zoneToShortOffset = zoneToShortOffset;
function validTzOffsetMinutes(tzOffsetMinutes) {
    return (tzOffsetMinutes != null &&
        (0, Number_1.isNumber)(tzOffsetMinutes) &&
        tzOffsetMinutes !== exports.UnsetZoneOffsetMinutes &&
        ValidOffsetMinutes().has(tzOffsetMinutes));
}
exports.validTzOffsetMinutes = validTzOffsetMinutes;
/**
 * Returns a "zone name" (used by `luxon`) that encodes the given offset.
 */
function offsetMinutesToZoneName(offsetMinutes) {
    if (!validTzOffsetMinutes(offsetMinutes)) {
        return undefined;
    }
    if (offsetMinutes === 0)
        return "UTC";
    const sign = offsetMinutes < 0 ? "-" : "+";
    const absMinutes = Math.abs(offsetMinutes);
    const hours = Math.floor(absMinutes / 60);
    const minutes = Math.abs(absMinutes % 60);
    // luxon now renders simple hour offsets without padding:
    return `UTC${sign}` + hours + (minutes === 0 ? "" : `:${(0, String_1.pad2)(minutes)}`);
}
exports.offsetMinutesToZoneName = offsetMinutesToZoneName;
function tzHourToOffset(n) {
    return (0, Number_1.isNumber)(n) && validTzOffsetMinutes(n * 60)
        ? offsetMinutesToZoneName(n * 60)
        : undefined;
}
// Accept "Z", "UTC+2", "UTC+02", "UTC+2:00", "UTC+02:00", "+2", "+02", and
// "+02:00". Require the sign (+ or -) and a ":" separator if there are
// minutes.
const tzRe = /(?<Z>Z)|((UTC)?(?<sign>[+-])(?<hours>\d\d?)(?::(?<minutes>\d\d))?)$/;
function extractOffsetFromHours(hourOffset) {
    return (0, Number_1.isNumber)(hourOffset)
        ? (0, Maybe_1.map)(tzHourToOffset(hourOffset), (tz) => ({
            tz,
            src: "hourOffset",
        }))
        : Array.isArray(hourOffset)
            ? extractOffsetFromHours(hourOffset[0])
            : undefined;
}
/**
 * Parse a timezone offset and return the offset minutes
 */
function extractZone(value, opts) {
    var _a, _b;
    if (value == null ||
        typeof value === "boolean" ||
        value instanceof BinaryField_1.BinaryField ||
        value instanceof ExifDate_1.ExifDate) {
        return;
    }
    if (Array.isArray(value)) {
        // we only ever care about the first non-null value
        return extractZone(value.find((ea) => ea != null));
    }
    if (value instanceof ExifDateTime_1.ExifDateTime || value instanceof ExifTime_1.ExifTime) {
        return value.zone == null
            ? undefined
            : { tz: value.zone, src: value.constructor.name + ".zone" };
    }
    if ((0, Number_1.isNumber)(value)) {
        return extractOffsetFromHours(value);
    }
    if (typeof value !== "string" || (0, String_1.blank)(value)) {
        // don't accept ExifDate, boolean, BinaryField, ResourceEvent, Struct, or
        // Version instances:
        return;
    }
    {
        // If value is a proper timezone name, this may be easy!
        const z = normalizeZone(value);
        if (z != null) {
            return { tz: z.name, src: "normalizeZone" };
        }
    }
    let str = value.trim();
    // Some EXIF datetime will "over-specify" and include both the utc offset
    // *and* the "time zone abbreviation"/TZA, like "PST" or "PDT". TZAs are
    // between 2 (AT) and 5 (WEST) characters.
    if ((opts === null || opts === void 0 ? void 0 : opts.stripTZA) !== false &&
        // We only want to strip off the TZA if the input _doesn't_ end with "UTC"
        // or "Z"
        !/[.\d\s](?:UTC|Z)$/.test(str)) {
        str = str.replace(/\s[a-z]{2,5}$/i, "");
    }
    {
        if ((0, String_1.blank)(str))
            return;
        const z = normalizeZone(str);
        if (z != null) {
            return { tz: z.name, src: "normalizeZone" };
        }
    }
    const match = tzRe.exec(str);
    const capturedGroups = match === null || match === void 0 ? void 0 : match.groups;
    if (match != null && capturedGroups != null) {
        const leftovers = str.slice(0, match.index);
        if (capturedGroups.Z === "Z")
            return {
                tz: "UTC",
                src: "Z",
                leftovers,
            };
        const offsetMinutes = (capturedGroups.sign === "-" ? -1 : 1) *
            (parseInt((_a = capturedGroups.hours) !== null && _a !== void 0 ? _a : "0") * 60 +
                parseInt((_b = capturedGroups.minutes) !== null && _b !== void 0 ? _b : "0"));
        const tz = offsetMinutesToZoneName(offsetMinutes);
        if (tz != null) {
            return { tz, src: "offsetMinutesToZoneName", leftovers };
        }
    }
    return;
}
exports.extractZone = extractZone;
const TimezoneOffsetTagnames = [
    "TimeZone",
    "OffsetTime",
    // time zone for DateTimeOriginal, "-08:00"
    "OffsetTimeOriginal",
    // time zone for CreateDate, "-08:00"
    "OffsetTimeDigitized",
    // srsly who came up with these wholly inconsistent tag names? _why not just
    // prefix tag names with "Offset"?!11_ SADNESS AND WOE
    // 1 or 2 values: 1. The time zone offset of DateTimeOriginal from GMT in
    // hours, 2. If present, the time zone offset of ModifyDate (which we
    // ignore) @see https://www.exiftool.org/TagNames/EXIF.html
    "TimeZoneOffset", // number | number[] | string
];
function extractTzOffsetFromTags(t) {
    // We have to iterate twice: if it's from a timezone offset tag, we can
    // trust it, even if it's UTC.
    for (const tagName of TimezoneOffsetTagnames) {
        if (t[tagName] != null) {
            const offset = extractZone(t[tagName]);
            if (offset != null) {
                return { tz: offset.tz, src: tagName };
            }
        }
    }
    return;
}
exports.extractTzOffsetFromTags = extractTzOffsetFromTags;
function extractTzOffsetFromDatestamps(t, opts) {
    var _a;
    if ((opts === null || opts === void 0 ? void 0 : opts.inferTimezoneFromDatestamps) === true) {
        for (const tagName of (_a = opts.inferTimezoneFromDatestampTags) !== null && _a !== void 0 ? _a : []) {
            if (t[tagName] != null) {
                const offset = extractZone(t[tagName]);
                // Some applications (looking at you, Google Takeout) will add a
                // spurious "+00:00" timezone offset to random datestamp tags, so
                // ignore UTC offsets here.
                if (offset != null && !isUTC(offset.tz)) {
                    return { tz: offset.tz, src: tagName };
                }
            }
        }
    }
    return;
}
exports.extractTzOffsetFromDatestamps = extractTzOffsetFromDatestamps;
// timezone offsets may be on a 15 minute boundary, but if GPS acquisition is
// old, this can be spurious. We get less mistakes with a larger multiple, so
// we're using 30 minutes instead of 15. See
// https://www.timeanddate.com/time/time-zones-interesting.html
const TzBoundaryMinutes = 30;
function inferLikelyOffsetMinutes(deltaMinutes) {
    return TzBoundaryMinutes * Math.floor(deltaMinutes / TzBoundaryMinutes);
}
exports.inferLikelyOffsetMinutes = inferLikelyOffsetMinutes;
/**
 * Convert blank strings to undefined.
 */
function blankToNull(x) {
    return x == null || (typeof x === "string" && (0, String_1.blank)(x)) ? undefined : x;
}
function extractTzOffsetFromUTCOffset(t) {
    const utcSources = {
        ...(0, Pick_1.pick)(t, "GPSDateTime", "DateTimeUTC"),
        GPSDateTimeStamp: (0, Maybe_1.map2)(blankToNull(t.GPSDateStamp), // Example: "2022:04:13"
        blankToNull(t.GPSTimeStamp), // Example: "23:59:41.001"
        (a, b) => a + " " + b),
    };
    // We can always assume these are in UTC:
    const utc = (0, Maybe_1.first)(["GPSDateTime", "DateTimeUTC", "GPSDateTimeStamp"], (tagName) => {
        var _a;
        const v = utcSources[tagName];
        const edt = v instanceof ExifDateTime_1.ExifDateTime ? v : ExifDateTime_1.ExifDateTime.fromExifStrict(v);
        const s = edt != null && (edt.zone == null || isUTC(edt.zone))
            ? (_a = edt.setZone("UTC", { keepLocalTime: true })) === null || _a === void 0 ? void 0 : _a.toEpochSeconds()
            : undefined;
        return s != null
            ? {
                tagName,
                s,
            }
            : undefined;
    });
    if (utc == null)
        return;
    // If we can find any of these without a zone, the timezone should be the
    // offset between this time and the GPS time.
    const dt = (0, Maybe_1.first)(CapturedAtTagNames_1.CapturedAtTagNames, (tagName) => {
        var _a;
        const edt = ExifDateTime_1.ExifDateTime.fromExifStrict(t[tagName]);
        const s = edt != null && edt.zone == null
            ? (_a = edt.setZone("UTC", { keepLocalTime: true })) === null || _a === void 0 ? void 0 : _a.toEpochSeconds()
            : undefined;
        return s != null
            ? {
                tagName,
                s,
            }
            : undefined;
    });
    if (dt == null)
        return;
    const diffSeconds = dt.s - utc.s;
    const offsetMinutes = inferLikelyOffsetMinutes(diffSeconds / 60);
    return (0, Maybe_1.map)(offsetMinutesToZoneName(offsetMinutes), (tz) => ({
        tz,
        src: `offset between ${dt.tagName} and ${utc.tagName}`,
    }));
}
exports.extractTzOffsetFromUTCOffset = extractTzOffsetFromUTCOffset;
function equivalentZones(a, b) {
    const az = normalizeZone(a);
    const bz = normalizeZone(b);
    return (az != null &&
        bz != null &&
        (az.equals(bz) || az.offset(Date.now()) === bz.offset(Date.now())));
}
exports.equivalentZones = equivalentZones;
function getZoneName(args = {}) {
    var _a, _b, _c, _d;
    const result = (_d = (_b = (_a = normalizeZone(args.zone)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : (_c = normalizeZone(args.zoneName)) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : offsetMinutesToZoneName(args.tzoffsetMinutes);
    return (0, String_1.blank)(result) || result === exports.UnsetZoneName ? undefined : result;
}
exports.getZoneName = getZoneName;
//# sourceMappingURL=Timezones.js.map